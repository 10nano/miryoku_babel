# Copyright 2019 Manna Harbour
# https://github.com/manna-harbour/miryoku

# After making changes to code or tables call org-babel-tangle (C-c C-v t).

* Miryoku Babel [[https://raw.githubusercontent.com/manna-harbour/miryoku/master/data/logos/miryoku-roa-32.png]]

[[https://raw.githubusercontent.com/manna-harbour/miryoku/master/data/cover/miryoku-kle-cover.png]]

[[https://github.com/manna-harbour/miryoku/][Miryoku]] is an ergonomic, minimal, orthogonal, and universal keyboard layout.  Miryoku Babel generates the keymap data for Miryoku implementations from org tables using [[https://orgmode.org/worg/org-contrib/babel/][babel]].


The layout is maintained in emacs org-mode tables and converted to keymap data structures using embedded python scripts.

- https://orgmode.org/
- https://orgmode.org/manual/Tables.html
- https://orgmode.org/manual/Working-with-Source-Code.html


** Building


*** Initial Setup


*** Tangling


** Layer Tables

The layers are maintained in tables.  ~U_NP~ indicates the key is not present and is used to fill in the table around the thumb keys.

Basic keycodes are entered without the ~KC_~ prefix.  Symbols can be entered as-is, except for '-' (~MINS~), '.' (~DOT~), '|' (~PIPE~), and '"' (~DQUO~). Empty cells are unused.

The base layer is maintained as separate tables for tap alphas, tap thumbs, and hold.  Other layers are specified as a single hand including thumbs.  Tables are combined to produce the keymap data for each layer.

Unknown names are considered to be layer names.


*** Base


**** Tap


***** Alphas

#+NAME: colemakdh
| Q     | W     | F     | P     | B     | J     | L     | U     | Y     | '     |
| A     | R     | S     | T     | G     | M     | N     | E     | I     | O     |
| Z     | X     | C     | D     | V     | K     | H     | ,     | DOT   | /     |


***** Thumbs

#+NAME: thumbs
| U_NP  | U_NP  | ESC   | SPC   | TAB   | ENT   | BSPC  | DEL   | U_NP  | U_NP  |


**** Hold

#+NAME: hold
| RESET  |        |        |        |        |        |        |        |        | RESET  |
| LGUI   | LALT   | LCTL   | LSFT   |        |        | LSFT   | LCTL   | LALT   | LGUI   |
| BUTTON | ALGR   |        |        |        |        |        |        | ALGR   | BUTTON |
| U_NP   | U_NP   | MEDIA  | NAV    | MOUSE  | SYM    | NUM    | FUN    | U_NP   | U_NP   |


*** Nav

#+NAME: nav-r
| U_RDO | U_PST | U_CPY | U_CUT | U_UND |
| CAPS  | LEFT  | DOWN  | UP    | RGHT  |
| INS   | HOME  | PGDN  | PGUP  | END   |
| ENT   | BSPC  | DEL   | U_NP  | U_NP  |


*** Mouse

#+NAME: mouse-r
| U_RDO | U_PST | U_CPY | U_CUT | U_UND |
|       | MS_L  | MS_D  | MS_U  | MS_R  |
|       | WH_L  | WH_D  | WH_U  | WH_R  |
| BTN1  | BTN3  | BTN2  | U_NP  | U_NP  |


*** Button

#+NAME: button
| U_UND | U_CUT | U_CPY | U_PST | U_RDO | U_RDO | U_PST | U_CPY | U_CUT | U_UND |
| LGUI  | LALT  | LCTL  | LSFT  |       |       | LSFT  | LCTL  | LALT  | LGUI  |
| U_UND | U_CUT | U_CPY | U_PST | U_RDO | U_RDO | U_PST | U_CPY | U_CUT | U_UND |
| U_NP  | U_NP  | BTN2  | BTN3  | BTN1  | BTN1  | BTN3  | BTN2  | U_NP  | U_NP  |


*** Media

#+NAME: media-r
| RGB_TOG  | RGB_MOD  | RGB_HUI  | RGB_SAI  | RGB_VAI  |
| OUT_AUTO | MPRV     | VOLD     | VOLU     | MNXT     |
| U_BTCLR  | U_BTSEL0 | U_BTSEL1 | U_BTSEL2 | U_BTSEL3 |
| MSTP     | MPLY     | MUTE     | U_NP     | U_NP     |


*** Num

#+NAME: num-l
| [    | 7    | 8    | 9    | ]    |
| ;    | 4    | 5    | 6    | =    |
| `    | 1    | 2    | 3    | \    |
| U_NP | U_NP | DOT  | 0    | MINS |


*** Sym

#+NAME: sym-l
| {    | &    | *    | (    | }    |
| :    | $    | %    | ^    | +    |
| ~    | !    | @    | #    | PIPE |
| U_NP | U_NP | (    | )    | _    |


*** Fun

#+NAME: fun-l
| F12  | F7   | F8   | F9   | PSCR |
| F11  | F4   | F5   | F6   | SLCK |
| F10  | F1   | F2   | F3   | PAUS |
| U_NP | U_NP | APP  | SPC  | TAB  |


*** Alternative Layouts


**** Alphas


***** AZERTY

~MIRYOKU_ALPHAS=AZERTY~

#+NAME: azerty
| A    | Z    | E    | R    | T    | Y    | U    | I    | O    | P    |
| Q    | S    | D    | F    | G    | H    | J    | K    | L    | M    |
| W    | X    | C    | V    | B    | N    | ,    | DOT  | /    | '    |


***** Colemak

~MIRYOKU_ALPHAS=COLEMAK~

#+NAME: colemak
| Q    | W    | F    | P    | G    | J    | L    | U    | Y    | '    |
| A    | R    | S    | T    | D    | H    | N    | E    | I    | O    |
| Z    | X    | C    | V    | B    | K    | M    | ,    | DOT  | /    |


***** Colemak Mod-DHk

~MIRYOKU_ALPHAS=COLEMAKDHK~

#+NAME: colemakdhk
| Q    | W    | F    | P    | B    | J    | L    | U    | Y    | '    |
| A    | R    | S    | T    | G    | K    | N    | E    | I    | O    |
| Z    | X    | C    | D    | V    | M    | H    | ,    | DOT  | /    |


***** Dvorak

~MIRYOKU_ALPHAS=DVORAK~

#+NAME: dvorak
| '    | ,    | DOT  | P    | Y    | F    | G    | C    | R    | L    |
| A    | O    | E    | U    | I    | D    | H    | T    | N    | S    |
| /    | Q    | J    | K    | X    | B    | M    | W    | V    | Z    |


***** Halmak

~MIRYOKU_ALPHAS=HALMAK~

#+NAME: halmak
| W    | L    | R    | B    | Z    | '    | Q    | U    | D    | J    |
| S    | H    | N    | T    | ,    | DOT  | A    | E    | O    | I    |
| F    | M    | V    | C    | /    | G    | P    | X    | K    | Y    |


***** Workman

~MIRYOKU_ALPHAS=WORKMAN~

#+NAME: workman
| Q    | D    | R    | W    | B    | J    | F    | U    | P    | '    |
| A    | S    | H    | T    | G    | Y    | N    | E    | O    | I    |
| Z    | X    | M    | C    | V    | K    | L    | ,    | DOT  | /    |


***** QWERTY

~MIRYOKU_ALPHAS=QWERTY~

#+NAME: qwerty
| Q    | W    | E    | R    | T    | Y    | U    | I    | O    | P    |
| A    | S    | D    | F    | G    | H    | J    | K    | L    | '    |
| Z    | X    | C    | V    | B    | N    | M    | ,    | DOT  | /    |


***** QWERTZ

~MIRYOKU_ALPHAS=QWERTZ~

#+NAME: qwertz
| Q    | W    | E    | R    | T    | Z    | U    | I    | O    | P    |
| A    | S    | D    | F    | G    | H    | J    | K    | L    | '    |
| Y    | X    | C    | V    | B    | N    | M    | ,    | DOT  | /    |


**** Nav


***** vi-Style

~MIRYOKU_NAV=VI~

Not available with ~MIRYOKU_LAYERS=FLIP~.


****** Nav

#+NAME: nav-r-vi
| U_RDO | U_PST | U_CPY | U_CUT | U_UND |
| LEFT  | DOWN  | UP    | RGHT  | CAPS  |
| HOME  | PGDN  | PGUP  | END   | INS   |
| ENT   | BSPC  | DEL   | U_NP  | U_NP  |


****** Mouse

#+NAME: mouse-r-vi
| U_RDO | U_PST | U_CPY | U_CUT | U_UND |
| MS_L  | MS_D  | MS_U  | MS_R  |       |
| WH_L  | WH_D  | WH_U  | WH_R  |       |
| BTN1  | BTN3  | BTN2  | U_NP  | U_NP  |


****** Media

#+NAME: media-r-vi
| RGB_TOG  | RGB_MOD  | RGB_HUI  | RGB_SAI  | RGB_VAI  |
| MPRV     | VOLD     | VOLU     | MNXT     | OUT_AUTO |
| U_BTSEL0 | U_BTSEL1 | U_BTSEL2 | U_BTSEL3 | U_BTCLR  |
| MSTP     | MPLY     | MUTE     | U_NP     | U_NP     |


***** Inverted-T

~MIRYOKU_NAV=INVERTEDT~

Only available with ~MIRYOKU_LAYERS=FLIP~.


****** Nav

#+NAME: nav-l-invertedt
| PGUP  | HOME  | UP    | END   | INS   |
| PGDN  | LEFT  | DOWN  | RGHT  | CAPS  |
| U_UND | U_CUT | U_CPY | U_PST | U_RDO |
| U_NP  | U_NP  | DEL   | BSPC  | ENT   |


****** Mouse

#+NAME: mouse-l-invertedt
| WH_U  | WH_L  | MS_U  | WH_R  |       |
| WH_D  | MS_L  | MS_D  | MS_R  |       |
| U_UND | U_CUT | U_CPY | U_PST | U_RDO |
| U_NP  | U_NP  | BTN2  | BTN3  | BTN1  |


****** Media

#+NAME: media-l-invertedt
| U_BTSEL0 | U_BTSEL1 | VOLU    | U_BTSEL2 | U_BTSEL3 |
| U_BTCLR  | MPRV     | VOLD    | MNXT     | OUT_AUTO |
| RGB_MOD  | RGB_HUI  | RGB_SAI | RGB_VAI  | RGB_TOG  |
| U_NP     | U_NP     | MUTE    | MPLY     | MSTP     |


**** Clipboard


***** Default

#+NAME: clipboard
| U_RDO | AGIN      |
| U_PST | S(KC_INS) |
| U_CPY | C(KC_INS) |
| U_CUT | S(KC_DEL) |
| U_UND | UNDO   |


***** Fun Cluster

~MIRYOKU_CLIPBOARD=FUN~

#+NAME: clipboard-fun
| U_RDO | AGIN |
| U_PST | PSTE |
| U_CPY | COPY |
| U_CUT | CUT  |
| U_UND | UNDO |


***** Mac

~MIRYOKU_CLIPBOARD=MAC~

#+NAME: clipboard-mac
| U_RDO | SCMD(KC_Z) |
| U_PST | LCMD(KC_V) |
| U_CPY | LCMD(KC_C) |
| U_CUT | LCMD(KC_X) |
| U_UND | LCMD(KC_Z) |


***** Windows

~MIRYOKU_CLIPBOARD=WIN~

#+NAME: clipboard-win
| U_RDO | C(KC_Y) |
| U_PST | C(KC_V) |
| U_CPY | C(KC_C) |
| U_CUT | C(KC_X) |
| U_UND | C(KC_Z) |


**** Layers


***** Flip

~MIRYOKU_LAYERS=FLIP~


****** Thumbs

#+NAME: thumbs-flip
| U_NP | U_NP | DEL  | BSPC | ENT  | TAB  | SPC  | ESC  | U_NP | U_NP |


****** Hold

#+NAME: hold-flip
| RESET  |        |        |        |        |        |        |        |        | RESET  |
| LGUI   | LALT   | LCTL   | LSFT   |        |        | LSFT   | LCTL   | LALT   | LGUI   |
| BUTTON | ALGR   |        |        |        |        |        |        | ALGR   | BUTTON |
| U_NP   | U_NP   | FUN    | NUM    | SYM    | MOUSE  | NAV    | MEDIA  | U_NP   | U_NP   |


****** Nav

#+NAME: nav-l
| HOME  | PGDN  | PGUP  | END   | INS   |
| LEFT  | DOWN  | UP    | RGHT  | CAPS  |
| U_UND | U_CUT | U_CPY | U_PST | U_RDO |
| U_NP  | U_NP  | DEL   | BSPC  | ENT   |


****** Mouse

#+NAME: mouse-l
| WH_L  | WH_D  | WH_U  | WH_R  |       |
| MS_L  | MS_D  | MS_U  | MS_R  |       |
| U_UND | U_CUT | U_CPY | U_PST | U_RDO |
| U_NP  | U_NP  | BTN2  | BTN3  | BTN1  |


****** Media

#+NAME: media-l
| RGB_MOD  | RGB_HUI  | RGB_SAI  | RGB_VAI  | RGB_TOG  |
| MPRV     | VOLD     | VOLU     | MNXT     | OUT_AUTO |
| U_BTSEL0 | U_BTSEL1 | U_BTSEL2 | U_BTSEL3 | U_BTCLR  |
| U_NP     | U_NP     | MUTE     | MPLY     | MSTP     |


****** Num

#+NAME: num-r
| [    | 7    | 8    | 9    | ]    |
| =    | 4    | 5    | 6    | ;    |
| \    | 1    | 2    | 3    | `    |
| MINS | 0    | DOT  | U_NP | U_NP |


****** Sym

#+NAME: sym-r
| {    | &    | *    | (    | }    |
| +    | $    | %    | ^    | :    |
| PIPE | !    | @    | #    | ~    |
| _    | (    | )    | U_NP | U_NP |


****** Fun

#+NAME: fun-r
| PSCR | F7   | F8   | F9   | F12  |
| SLCK | F4   | F5   | F6   | F11  |
| PAUS | F1   | F2   | F3   | F10  |
| TAB  | SPC  | APP  | U_NP | U_NP |


*** COMMENT Templates

#+NAME: tem
| <l4> | <l4> | <l4> | <l4> | <l4> | <l4> | <l4> | <l4> | <l4> | <l4> |
|------+------+------+------+------+------+------+------+------+------|
|      |      |      |      |      |      |      |      |      |      |
|      |      |      |      |      |      |      |      |      |      |
|      |      |      |      |      |      |      |      |      |      |
| U_NP | U_NP |      |      |      |      |      |      | U_NP | U_NP |

#+NAME: tem-r
| <l4> | <l4> | <l4> | <l4> | <l4> |
|------+------+------+------+------|
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |
| ENT  | BSPC | DEL  | U_NP | U_NP |

#+NAME: tem-l
| <l4> | <l4> | <l4> | <l4> | <l4> |
|------+------+------+------+------|
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |
| U_NP | U_NP | ESC  | SPC  | TAB  |


** Code Generation


*** Common


**** symbol-names

Symbol, name, and shifted symbol mappings for use in tables.

#+NAME: symbol-names
| `    | GRV  | ~    | TILD |
| "-"  | MINS | _    | UNDS |
| =    | EQL  | +    | PLUS |
| [    | LBRC | {    | LCBR |
| ]    | RBRC | }    | RCBR |
| \    | BSLS | PIPE | PIPE |
| ;    | SCLN | :    | COLN |
| '    | QUOT | DQUO | DQUO |
| ,    | COMM | <    | LT   |
| "."  | DOT  | >    | GT   |
| /    | SLSH | ?    | QUES |
| 1    | 1    | !    | EXLM |
| 2    | 2    | @    | AT   |
| 3    | 3    | #    | HASH |
| 4    | 4    | $    | DLR  |
| 5    | 5    | %    | PERC |
| 6    | 6    | ^    | CIRC |
| 7    | 7    | &    | AMPR |
| 8    | 8    | *    | ASTR |
| 9    | 9    | (    | LPRN |
| 0    | 0    | )    | RPRN |


**** mods

Modifiers usable in hold table.  Need to have the same name for ~KC_~ and ~_T~
versions.

#+NAME: mods
| LSFT | LCTL | LALT | LGUI | ALGR |


**** header

Header for tangled files.

#+NAME: header
#+BEGIN_SRC C :main no :tangle no
Copyright 2019 Manna Harbour
https://github.com/manna-harbour/miryoku
generated -*- buffer-read-only: t -*-
#+END_SRC


**** keycode-translation

standard keycode to implementation equivalent (standard, qmk, zmk)

#+NAME: keycode-translation
| 0          | 0          | NUM_0           |
| 1          | 1          | NUM_1           |
| 2          | 2          | NUM_2           |
| 3          | 3          | NUM_3           |
| 4          | 4          | NUM_4           |
| 5          | 5          | NUM_5           |
| 6          | 6          | NUM_6           |
| 7          | 7          | NUM_7           |
| 8          | 8          | NUM_8           |
| 9          | 9          | NUM_9           |
| AGIN       | AGIN       | K_AGAIN         |
| ALGR       | ALGR       | RALT            |
| AMPR       | AMPR       | AMPS            |
| APP        | APP        | K_APP           |
| ASTR       | ASTR       | ASTRK           |
| AT         | AT         | AT              |
| BSLS       | BSLS       | BSLH            |
| BSPC       | BSPC       | BSPC            |
| U_BTCLR    | U_NU       | &bt BT_CLR      |
| U_BTSEL0   | U_NU       | &bt BT_SEL 0    |
| U_BTSEL1   | U_NU       | &bt BT_SEL 1    |
| U_BTSEL2   | U_NU       | &bt BT_SEL 2    |
| U_BTSEL3   | U_NU       | &bt BT_SEL 3    |
| U_BTSEL4   | U_NU       | &bt BT_SEL 4    |
| BTN1       | BTN1       | KP_N5           |
| BTN2       | BTN2       | U_NU            |
| BTN3       | BTN3       | U_NU            |
| CAPS       | CAPS       | CAPS            |
| CIRC       | CIRC       | CRRT            |
| COLN       | COLN       | COLON           |
| COMM       | COMM       | COMMA           |
| COPY       | COPY       | K_COPY          |
| CUT        | CUT        | K_CUT           |
| DEL        | DEL        | DEL             |
| DLR        | DLR        | DLLR            |
| DOT        | DOT        | DOT             |
| DOWN       | DOWN       | DOWN            |
| DQUO       | DQUO       | DQT             |
| END        | END        | END             |
| ENT        | ENT        | RET             |
| EQL        | EQL        | EQL             |
| ESC        | ESC        | ESC             |
| EXLM       | EXLM       | EXCL            |
| F1         | F1         | F1              |
| F2         | F2         | F2              |
| F3         | F3         | F3              |
| F4         | F4         | F4              |
| F5         | F5         | F5              |
| F6         | F6         | F6              |
| F7         | F7         | F7              |
| F8         | F8         | F8              |
| F9         | F9         | F9              |
| F10        | F10        | F10             |
| F11        | F11        | F11             |
| F12        | F12        | F12             |
| GRV        | GRV        | GRAVE           |
| GT         | GT         | GT              |
| HASH       | HASH       | HASH            |
| HOME       | HOME       | HOME            |
| INS        | INS        | INS             |
| LALT       | LALT       | LALT            |
| LBRC       | LBRC       | LBKT            |
| LCBR       | LCBR       | LBRC            |
| LCTL       | LCTL       | LCTRL           |
| LEFT       | LEFT       | LEFT            |
| LGUI       | LGUI       | LGUI            |
| LPRN       | LPRN       | LPAR            |
| LSFT       | LSFT       | LSHFT           |
| LT         | LT         | LT              |
| MINS       | MINS       | MINUS           |
| MNXT       | MNXT       | C_NEXT          |
| MPLY       | MPLY       | C_PP            |
| MPRV       | MPRV       | C_PREV          |
| MS_D       | MS_D       | KP_N2           |
| MS_L       | MS_L       | KP_N4           |
| MS_R       | MS_R       | KP_N6           |
| MS_U       | MS_U       | KP_N8           |
| MSTP       | MSTP       | C_STOP          |
| MUTE       | MUTE       | C_MUTE          |
| OUT_AUTO   | OUT_AUTO   | &out OUT_TOG    |
| OUT_BT     | OUT_BT     | &out OUT_BT     |
| OUT_USB    | OUT_USB    | &out OUT_USB    |
| PAUS       | PAUS       | PAUSE_BREAK     |
| PERC       | PERC       | PRCT            |
| PGDN       | PGDN       | PG_DN           |
| PGUP       | PGUP       | PG_UP           |
| PIPE       | PIPE       | PIPE            |
| PLUS       | PLUS       | PLUS            |
| PSCR       | PSCR       | PSCRN           |
| PSTE       | PSTE       | K_PASTE         |
| QUES       | QUES       | QMARK           |
| QUOT       | QUOT       | SQT             |
| RBRC       | RBRC       | RBKT            |
| RCBR       | RCBR       | RBRC            |
| RESET      | RESET      | &bootloader     |
| RGB_HUI    | RGB_HUI    | &rgb_ug RGB_HUI |
| RGB_MOD    | RGB_MOD    | &rgb_ug RGB_EFF |
| RGB_SAI    | RGB_SAI    | &rgb_ug RGB_SAI |
| RGB_TOG    | RGB_TOG    | &rgb_ug RGB_TOG |
| RGB_VAI    | RGB_VAI    | &rgb_ug RGB_BRI |
| RGHT       | RGHT       | RIGHT           |
| RPRN       | RPRN       | RPAR            |
| SCLN       | SCLN       | SEMI            |
| SLCK       | SLCK       | SLCK            |
| SLSH       | SLSH       | SLASH           |
| SPC        | SPC        | SPC             |
| TAB        | TAB        | TAB             |
| TILD       | TILD       | TILDE           |
| UNDO       | UNDO       | K_UNDO          |
| UNDS       | UNDS       | UNDER           |
| UP         | UP         | UP              |
| VOLD       | VOLD       | C_VOL_DN        |
| VOLU       | VOLU       | C_VOL_UP        |
| WH_D       | WH_D       | U_NU            |
| WH_L       | WH_L       | U_NU            |
| WH_R       | WH_R       | U_NU            |
| WH_U       | WH_U       | U_NU            |
| S(KC_INS)  | S(KC_INS)  | LS(INS)         |
| C(KC_INS)  | C(KC_INS)  | LC(INS)         |
| S(KC_DEL)  | S(KC_DEL)  | LS(DEL)         |
| SCMD(KC_Z) | SCMD(KC_Z) | LS(LG(Z))       |
| LCMD(KC_V) | LCMD(KC_V) | LG(V)           |
| LCMD(KC_C) | LCMD(KC_C) | LG(C)           |
| LCMD(KC_X) | LCMD(KC_X) | LG(X)           |
| LCMD(KC_Z) | LCMD(KC_Z) | LG(Z)           |
| C(KC_Y)    | C(KC_Y)    | LC(Y)           |
| C(KC_V)    | C(KC_V)    | LC(V)           |
| C(KC_C)    | C(KC_C)    | LC(C)           |
| C(KC_X)    | C(KC_X)    | LC(X)           |
| C(KC_Z)    | C(KC_Z)    | LC(Z)           |
| DF(TAP)    | DF(TAP)    | &tog TAP        |
| U_MT       | U_MT       | LS(LNLCK)       |


**** COMMENT python-version

C-c C-c in code block to update

#+NAME: python-version
#+BEGIN_SRC python :tangle no
import sys
return sys.version
#+END_SRC


*** Miryoku QMK


**** nonkc

Keycodes that match any of these prefixes will not have ~KC_~ automatically
prepended.

#+NAME: nonkc
| U_ | RGB_ | OUT_ | RESET | S( | C( | SCMD( | LCMD( |


**** license-qmk

License for tangled QMK C source files.

#+NAME: license-qmk
#+BEGIN_SRC C :main no :tangle no
// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see <http://www.gnu.org/licenses/>.
#+END_SRC


**** table-layout-taphold

Produce base layer from separate tap and hold tables.

#+NAME: table-layout-taphold
#+BEGIN_SRC python :var alphas_table=colemakdh :var thumbs_table=thumbs :var hold_table=hold :var symbol_names_table=symbol-names :var mods_table=mods :var nonkc_table=nonkc :var keycode_translation_table=keycode-translation :tangle no :results verbatim
width = 19
mods_dict = dict.fromkeys(mods_table[0])
nonkc_tuple = tuple(nonkc_table[0])
symbol_names_dict = {}
for symbol, name, shifted_symbol, shifted_name in symbol_names_table:
  symbol_names_dict[symbol] = name
  symbol_names_dict[shifted_symbol] = shifted_name
keycode_translation_dict = {}
for standard, qmk, zmk in keycode_translation_table:
  keycode_translation_dict[standard] = qmk
results = ''
for tap_row, hold_row in zip(alphas_table + thumbs_table, hold_table):
  results += '    '
  for tap, hold in zip(tap_row, hold_row):
    if tap == '':
      code = 'U_NU'
    elif tap in symbol_names_dict:
      code = symbol_names_dict[tap]
    else:
      code = tap
    if code in keycode_translation_dict:
      code = keycode_translation_dict[code]
    if not str(code).startswith(nonkc_tuple):
      code = 'KC_' + str(code)
    if hold in mods_dict:
      if hold in keycode_translation_dict:
        hold = keycode_translation_dict[hold]
      code = str(hold) + '_T(' + code + ')'
    elif hold != '' and hold != 'U_NP' and hold != 'RESET':
      code = 'LT(' + str(hold) + ', ' + code + ')'
    results += (code + ', ').ljust(width)
  results = results.rstrip(' ') + '\n'
results = results.rstrip('\n, ')
return results
#+END_SRC

#+RESULTS: table-layout-taphold
:     KC_Q,              KC_W,              KC_F,              KC_P,              KC_B,              KC_J,              KC_L,              KC_U,              KC_Y,              KC_QUOT,
:     LGUI_T(KC_A),      LALT_T(KC_R),      LCTL_T(KC_S),      LSFT_T(KC_T),      KC_G,              KC_M,              LSFT_T(KC_N),      LCTL_T(KC_E),      LALT_T(KC_I),      LGUI_T(KC_O),
:     LT(BUTTON, KC_Z),  ALGR_T(KC_X),      KC_C,              KC_D,              KC_V,              KC_K,              KC_H,              KC_COMM,           ALGR_T(KC_DOT),    LT(BUTTON, KC_SLSH),
:     U_NP,              U_NP,              LT(MEDIA, KC_ESC), LT(NAV, KC_SPC),   LT(MOUSE, KC_TAB), LT(SYM, KC_ENT),   LT(NUM, KC_BSPC),  LT(FUN, KC_DEL),   U_NP,              U_NP


**** table-layout-half

Produce sub layers given layer name and corresponding table for single hand and
incorporating mods and reset from base layer.  Layer names must end with 'R' or
'L'.  A layer with shifted symbols can also be generated.

#+NAME: table-layout-half
#+BEGIN_SRC python :var hold_table=hold :var mode="r" :var half_table=media-r :var symbol_names_table=symbol-names :var mods_table=mods :var nonkc_table=nonkc :var shift="false" :var keycode_translation_table=keycode-translation :tangle no :results verbatim
width = 19
mods_dict = dict.fromkeys(mods_table[0])
nonkc_tuple = tuple(nonkc_table[0])
symbol_names_dict = {}
shifted_symbol_names_dict = {}
for symbol, name, shifted_symbol, shifted_name in symbol_names_table:
  symbol_names_dict[symbol] = name
  symbol_names_dict[shifted_symbol] = shifted_name
  shifted_symbol_names_dict[symbol] = shifted_name
length = len(half_table[0])
keycode_translation_dict = {}
for standard, qmk, zmk in keycode_translation_table:
  keycode_translation_dict[standard] = qmk
results = ''
for half_row, hold_row in zip(half_table, hold_table):
  results += '    '
  hold_row_l, hold_row_r = hold_row[:length], hold_row[length:]
  for lr, hold_row_lr in ('l', hold_row_l), ('r', hold_row_r):
    if lr == mode:
      for half in half_row:
        if half == '':
          code = 'U_NU'
        elif shift == "true" and half in shifted_symbol_names_dict:
          code = shifted_symbol_names_dict[half]
        elif half in symbol_names_dict:
          code = symbol_names_dict[half]
        else:
          code = half
        if code in keycode_translation_dict:
          code = keycode_translation_dict[code]
        if not str(code).startswith(nonkc_tuple):
          code = 'KC_' + str(code)
        results += (str(code) + ', ').ljust(width)
    else:
      for hold in hold_row_lr:
        if hold == '' or hold != 'U_NP' and hold != 'RESET' and hold not in mods_dict:
          code = 'U_NA'
        else:
          code = hold
          if hold in keycode_translation_dict:
            hold = keycode_translation_dict[hold]
        if not str(code).startswith(nonkc_tuple):
          code = 'KC_' + str(code)
        results += (str(code) + ', ').ljust(width)
  results = results.rstrip(' ') + '\n'
results = results.rstrip('\n, ')
return results
#+END_SRC

#+RESULTS: table-layout-half
:     RESET,             U_NA,              U_NA,              U_NA,              U_NA,              RGB_TOG,           RGB_MOD,           RGB_HUI,           RGB_SAI,           RGB_VAI,
:     KC_LGUI,           KC_LALT,           KC_LCTL,           KC_LSFT,           U_NA,              OUT_AUTO,          KC_MPRV,           KC_VOLD,           KC_VOLU,           KC_MNXT,
:     U_NA,              KC_ALGR,           U_NA,              U_NA,              U_NA,              U_NU,              U_NU,              U_NU,              U_NU,              U_NU,
:     U_NP,              U_NP,              U_NA,              U_NA,              U_NA,              KC_MSTP,           KC_MPLY,           KC_MUTE,           U_NP,              U_NP


**** table-layout-full

Produce full layer from single table.  Fill for unused keys is configurable.

#+NAME: table-layout-full
#+BEGIN_SRC python :var table=button :var fill="TRNS" :var symbol_names_table=symbol-names :var nonkc_table=nonkc :var keycode_translation_table=keycode-translation :tangle no :results verbatim
width = 19
symbol_names_dict = {}
nonkc_tuple = tuple(nonkc_table[0])
for symbol, name, shifted_symbol, shifted_name in symbol_names_table:
  symbol_names_dict[symbol] = name
  symbol_names_dict[shifted_symbol] = shifted_name
keycode_translation_dict = {}
for standard, qmk, zmk in keycode_translation_table:
  keycode_translation_dict[standard] = qmk
results = ''
for row in table:
  results += '    '
  for key in row:
    if key == '':
      code = fill
    elif key in symbol_names_dict:
      code = symbol_names_dict[key]
    else:
      code = key
    if code in keycode_translation_dict:
      code = keycode_translation_dict[code]
    if not str(code).startswith(nonkc_tuple):
      code = 'KC_' + str(code)
    results += (code + ', ').ljust(width)
  results = results.rstrip(' ') + '\n'
results = results.rstrip('\n, ')
return results
#+END_SRC

#+RESULTS: table-layout-full
:     U_UND,             U_CUT,             U_CPY,             U_PST,             U_RDO,             U_RDO,             U_PST,             U_CPY,             U_CUT,             U_UND,
:     KC_LGUI,           KC_LALT,           KC_LCTL,           KC_LSFT,           KC_TRNS,           KC_TRNS,           KC_LSFT,           KC_LCTL,           KC_LALT,           KC_LGUI,
:     U_UND,             U_CUT,             U_CPY,             U_PST,             U_RDO,             U_RDO,             U_PST,             U_CPY,             U_CUT,             U_UND,
:     U_NP,              U_NP,              KC_BTN2,           KC_BTN3,           KC_BTN1,           KC_BTN1,           KC_BTN3,           KC_BTN2,           U_NP,              U_NP


**** table-enums

Produce layer enums from layer names in hold table.

#+NAME: table-enums
#+BEGIN_SRC python :var hold_table=hold :var mods_table=mods :tangle no
mods_dict = dict.fromkeys(mods_table[0])
layers = [ 'BASE', 'BUTTON' ]
for hold_row in hold_table:
  for hold in hold_row:
    if hold not in mods_dict and hold != '' and hold != 'U_NP' and hold != 'RESET' and hold not in layers:
      layers.append(hold)
results = 'enum layers { ' + ', '.join(layers) + ' };'
return results
#+END_SRC

#+RESULTS: table-enums
: enum layers { BASE, BUTTON, MEDIA, NAV, MOUSE, SYM, NUM, FUN };


**** table-keycode-mappings

Produce keycode mappings according to the provided table.

#+NAME: table-keycode-mappings
#+BEGIN_SRC python :var table=clipboard :var symbol_names_table=symbol-names :var nonkc_table=nonkc :var keycode_translation_table=keycode-translation :tangle no
nonkc_tuple = tuple(nonkc_table[0])
symbol_names_dict = {}
for symbol, name, shifted_symbol, shifted_name in symbol_names_table:
  symbol_names_dict[symbol] = name
  symbol_names_dict[shifted_symbol] = shifted_name
keycode_translation_dict = {}
for standard, qmk, zmk in keycode_translation_table:
  keycode_translation_dict[standard] = qmk
results = ''
for f,t in table:
  if t == '':
    code = 'U_NU'
  elif t in symbol_names_dict:
    code = symbol_names_dict[t]
  else:
    code = t
  if code in keycode_translation_dict:
    code = keycode_translation_dict[code]
  if not str(code).startswith(nonkc_tuple):
    code = 'KC_' + str(code)
  results += '#define ' + f + ' ' + code + '\n'
return results
#+END_SRC

#+RESULTS: table-keycode-mappings
: #define U_RDO KC_AGIN
: #define U_PST S(KC_INS)
: #define U_CPY C(KC_INS)
: #define U_CUT S(KC_DEL)
: #define U_UND KC_UNDO


*** Miryoku ZMK


**** layers

#+NAME: layers
| BASE | TAP | BUTTON | NAV | MOUSE | MEDIA | NUM | SYM | FUN |


**** nonkp

Keycodes that match any of these prefixes will not have ~&kp~ automatically
prepended.

#+NAME: nonkp
| U_ | & |


**** table-map-taphold

#+NAME: table-map-taphold
#+BEGIN_SRC python :var alphas_table=colemakdh :var thumbs_table=thumbs :var hold_table=hold :var symbol_names_table=symbol-names :var mods_table=mods :var nonkp_table=nonkp :var layers_table=layers :var keycode_translation_table=keycode-translation :tangle no :results verbatim
width = 17
mods_dict = dict.fromkeys(mods_table[0])
nonkp_tuple = tuple(nonkp_table[0])
layers_dict = dict.fromkeys(layers_table[0])
symbol_names_dict = {}
for symbol, name, shifted_symbol, shifted_name in symbol_names_table:
  symbol_names_dict[symbol] = name
  symbol_names_dict[shifted_symbol] = shifted_name
keycode_translation_dict = {}
for standard, qmk, zmk in keycode_translation_table:
  keycode_translation_dict[standard] = zmk
results = ''
for tap_row, hold_row in zip(alphas_table + thumbs_table, hold_table):
  for tap, hold in zip(tap_row, hold_row):
    if tap == '':
      code = 'U_NU'
    elif tap in symbol_names_dict:
      code = symbol_names_dict[tap]
    else:
      code = tap
    if code in keycode_translation_dict:
      code = keycode_translation_dict[code]
    if hold in mods_dict:
      if hold in keycode_translation_dict:
        hold = keycode_translation_dict[hold]
      code = '&hm ' + str(hold) + ' ' + code
    elif hold in layers_dict:
      code = '&lt ' + str(hold) + ' ' + code
    elif not str(code).startswith(nonkp_tuple):
      code = '&kp ' + str(code)
    results += (code + ', ').ljust(width)
  results = results.rstrip(' ') + '\n'
results = results.rstrip('\n, ')
return results
#+END_SRC

#+RESULTS: table-map-taphold
: &kp Q,           &kp W,           &kp F,           &kp P,           &kp B,           &kp J,           &kp L,           &kp U,           &kp Y,           &kp SQT,
: &hm LGUI A,      &hm LALT R,      &hm LCTRL S,     &hm LSHFT T,     &kp G,           &kp M,           &hm LSHFT N,     &hm LCTRL E,     &hm LALT I,      &hm LGUI O,
: &lt BUTTON Z,    &hm RALT X,      &kp C,           &kp D,           &kp V,           &kp K,           &kp H,           &kp COMMA,       &hm RALT DOT,    &lt BUTTON SLASH,
: U_NP,            U_NP,            &lt MEDIA ESC,   &lt NAV SPC,     &lt MOUSE TAB,   &lt SYM RET,     &lt NUM BSPC,    &lt FUN DEL,     U_NP,            U_NP


**** table-map-half

#+NAME: table-map-half
#+BEGIN_SRC python :var hold_table=hold :var mode="r" :var half_table=mouse-r :var symbol_names_table=symbol-names :var mods_table=mods :var nonkp_table=nonkp :var shift="false" :var layers_table=layers :var keycode_translation_table=keycode-translation :tangle no :results verbatim
width = 17
mods_dict = dict.fromkeys(mods_table[0])
layers_dict = dict.fromkeys(layers_table[0])
nonkp_tuple = tuple(nonkp_table[0])
symbol_names_dict = {}
shifted_symbol_names_dict = {}
for symbol, name, shifted_symbol, shifted_name in symbol_names_table:
  symbol_names_dict[symbol] = name
  symbol_names_dict[shifted_symbol] = shifted_name
  shifted_symbol_names_dict[symbol] = shifted_name
keycode_translation_dict = {}
for standard, qmk, zmk in keycode_translation_table:
  keycode_translation_dict[standard] = zmk
length = len(half_table[0])
results = ''
for half_row, hold_row in zip(half_table, hold_table):
  hold_row_l, hold_row_r = hold_row[:length], hold_row[length:]
  for lr, hold_row_lr in ('l', hold_row_l), ('r', hold_row_r):
    if lr == mode:
      for half in half_row:
        if half == '':
          code = 'U_NU'
        elif shift == "true" and half in shifted_symbol_names_dict:
          code = shifted_symbol_names_dict[half]
        elif half in symbol_names_dict:
          code = symbol_names_dict[half]
        else:
          code = half
        if code in keycode_translation_dict:
          code = keycode_translation_dict[code]
        if not str(code).startswith(nonkp_tuple):
          code = '&kp ' + str(code)
        results += (str(code) + ', ').ljust(width)
    else:
      for hold in hold_row_lr:
        if hold in mods_dict:
          if hold in keycode_translation_dict:
            hold = keycode_translation_dict[hold]
          code = '&kp ' + str(hold)
        else:
          if hold in keycode_translation_dict:
            hold = keycode_translation_dict[hold]
          if hold == '' or hold in layers_dict:
            code = 'U_NA'
          elif str(hold).startswith(nonkp_tuple):
            code = hold
          else:
            code = '&kp ' + str(hold)
        results += (str(code) + ', ').ljust(width)
  results = results.rstrip(' ') + '\n'
results = results.rstrip('\n, ')
return results
#+END_SRC

#+RESULTS: table-map-half
: &bootloader,     U_NA,            U_NA,            U_NA,            U_NA,            U_RDO,           U_PST,           U_CPY,           U_CUT,           U_UND,
: &kp LGUI,        &kp LALT,        &kp LCTRL,       &kp LSHFT,       U_NA,            U_NU,            &kp KP_N4,       &kp KP_N2,       &kp KP_N8,       &kp KP_N6,
: U_NA,            &kp RALT,        U_NA,            U_NA,            U_NA,            U_NU,            U_NU,            U_NU,            U_NU,            U_NU,
: U_NP,            U_NP,            U_NA,            U_NA,            U_NA,            &kp KP_N5,       U_NU,            U_NU,            U_NP,            U_NP


**** table-map-full

#+NAME: table-map-full
#+BEGIN_SRC python :var table=button :var fill="&trans" :var symbol_names_table=symbol-names :var nonkp_table=nonkp :var keycode_translation_table=keycode-translation :tangle no :results verbatim
width = 17
symbol_names_dict = {}
nonkp_tuple = tuple(nonkp_table[0])
for symbol, name, shifted_symbol, shifted_name in symbol_names_table:
  symbol_names_dict[symbol] = name
  symbol_names_dict[shifted_symbol] = shifted_name
keycode_translation_dict = {}
for standard, qmk, zmk in keycode_translation_table:
  keycode_translation_dict[standard] = zmk
results = ''
for row in table:
  for key in row:
    if key == '':
      code = fill
    elif key in symbol_names_dict:
      code = symbol_names_dict[key]
    else:
      code = key
    if code in keycode_translation_dict:
      code = keycode_translation_dict[code]
    if not str(code).startswith(nonkp_tuple):
      code = '&kp ' + str(code)
    results += (code + ', ').ljust(width)
  results = results.rstrip(' ') + '\n'
results = results.rstrip('\n, ')
return results
#+END_SRC

#+RESULTS: table-map-full
: U_UND,           U_CUT,           U_CPY,           U_PST,           U_RDO,           U_RDO,           U_PST,           U_CPY,           U_CUT,           U_UND,
: &kp LGUI,        &kp LALT,        &kp LCTRL,       &kp LSHFT,       &trans,          &trans,          &kp LSHFT,       &kp LCTRL,       &kp LALT,        &kp LGUI,
: U_UND,           U_CUT,           U_CPY,           U_PST,           U_RDO,           U_RDO,           U_PST,           U_CPY,           U_CUT,           U_UND,
: U_NP,            U_NP,            U_NU,            U_NU,            &kp KP_N5,       &kp KP_N5,       U_NU,            U_NU,            U_NP,            U_NP


**** table-layer-defines

#+NAME: table-layer-defines
#+BEGIN_SRC python :var layers_table=layers :tangle no
width = 7
layers_list = layers_table[0]
results = ''
i = 0
for layer in layers_list:
  results += '#define ' + ( layer + ' ').ljust(width) + str(i) + '\n'
  i += 1
return results
#+END_SRC

#+RESULTS: table-layer-defines
: #define BASE   0
: #define TAP    1
: #define BUTTON 2
: #define NAV    3
: #define MOUSE  4
: #define MEDIA  5
: #define NUM    6
: #define SYM    7
: #define FUN    8


**** table-keycode-mappings-zmk

#+NAME: table-keycode-mappings-zmk
#+BEGIN_SRC python :var table=clipboard :var symbol_names_table=symbol-names :var nonkp_table=nonkp :var keycode_translation_table=keycode-translation :tangle no
nonkp_tuple = tuple(nonkp_table[0])
symbol_names_dict = {}
for symbol, name, shifted_symbol, shifted_name in symbol_names_table:
  symbol_names_dict[symbol] = name
  symbol_names_dict[shifted_symbol] = shifted_name
results = ''
keycode_translation_dict = {}
for standard, qmk, zmk in keycode_translation_table:
  keycode_translation_dict[standard] = zmk
for f,t in table:
  if t == '':
    code = 'U_NU'
  elif t in symbol_names_dict:
    code = symbol_names_dict[t]
  else:
    code = t
  if code in keycode_translation_dict:
    code = keycode_translation_dict[code]
  if not str(code).startswith(nonkp_tuple):
    code = '&kp ' + str(code)
  results += '#define ' + f + ' ' + code + '\n'
return results
#+END_SRC

#+RESULTS: table-keycode-mappings-zmk
: #define U_RDO &kp K_AGAIN
: #define U_PST &kp LS(INS)
: #define U_CPY &kp LC(INS)
: #define U_CUT &kp LS(DEL)
: #define U_UND &kp K_UNDO


** Tangled Files


*** Miryoku QMK


**** [[./qmk/layers.h]]

#+BEGIN_SRC C :main no :noweb yes :padline no :tangle qmk/layers.h
// <<header>>

<<license-qmk>>

<<table-enums()>>

#+END_SRC


**** [[./clipboard.h]]

#+BEGIN_SRC C :main no :noweb yes :padline no :tangle qmk/clipboard.h
// <<header>>

<<license-qmk>>

#if defined MIRYOKU_CLIPBOARD_FUN
<<table-keycode-mappings(table=clipboard-fun)>>
#elif defined MIRYOKU_CLIPBOARD_MAC
<<table-keycode-mappings(table=clipboard-mac)>>
#elif defined MIRYOKU_CLIPBOARD_WIN
<<table-keycode-mappings(table=clipboard-win)>>
#else
<<table-keycode-mappings(table=clipboard)>>
#endif

#+END_SRC


**** [[./qmk/keymaps.h]]

#+BEGIN_SRC C :main no :noweb yes :padline no :tangle qmk/keymaps.h
// <<header>>

<<license-qmk>>

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
#if defined MIRYOKU_LAYERS_FLIP
  [BASE] = LAYOUT_miryoku(
  #if defined MIRYOKU_ALPHAS_AZERTY
<<table-layout-taphold(alphas_table=azerty, thumbs_table=thumbs-flip, hold_table=hold-flip)>>
  #elif defined MIRYOKU_ALPHAS_COLEMAK
<<table-layout-taphold(alphas_table=colemak, thumbs_table=thumbs-flip, hold_table=hold-flip)>>
  #elif defined MIRYOKU_ALPHAS_COLEMAKDHK
<<table-layout-taphold(alphas_table=colemakdhk, thumbs_table=thumbs-flip, hold_table=hold-flip)>>
  #elif defined MIRYOKU_ALPHAS_DVORAK
<<table-layout-taphold(alphas_table=dvorak, thumbs_table=thumbs-flip, hold_table=hold-flip)>>
  #elif defined MIRYOKU_ALPHAS_HALMAK
<<table-layout-taphold(alphas_table=halmak, thumbs_table=thumbs-flip, hold_table=hold-flip)>>
  #elif defined MIRYOKU_ALPHAS_WORKMAN
<<table-layout-taphold(alphas_table=workman, thumbs_table=thumbs-flip, hold_table=hold-flip)>>
  #elif defined MIRYOKU_ALPHAS_QWERTY
<<table-layout-taphold(alphas_table=qwerty, thumbs_table=thumbs-flip, hold_table=hold-flip)>>
  #elif defined MIRYOKU_ALPHAS_QWERTZ
<<table-layout-taphold(alphas_table=qwertz, thumbs_table=thumbs-flip, hold_table=hold-flip)>>
  #else
<<table-layout-taphold(alphas_table=colemakdh, thumbs_table=thumbs-flip, hold_table=hold-flip)>>
  #endif
  ),
  #if defined MIRYOKU_NAV_INVERTEDT
  [NAV] = LAYOUT_miryoku(
<<table-layout-half(half_table=nav-l-invertedt, mode="l", hold_table=hold-flip)>>
  ),
  [MOUSE] = LAYOUT_miryoku(
<<table-layout-half(half_table=mouse-l-invertedt, mode="l", hold_table=hold-flip)>>
  ),
  [MEDIA] = LAYOUT_miryoku(
<<table-layout-half(half_table=media-l-invertedt, mode="l", hold_table=hold-flip)>>
  ),
  #else
  [NAV] = LAYOUT_miryoku(
<<table-layout-half(half_table=nav-l, mode="l", hold_table=hold-flip)>>
  ),
  [MOUSE] = LAYOUT_miryoku(
<<table-layout-half(half_table=mouse-l, mode="l", hold_table=hold-flip)>>
  ),
  [MEDIA] = LAYOUT_miryoku(
<<table-layout-half(half_table=media-l, mode="l", hold_table=hold-flip)>>
  ),
  #endif
  [NUM] = LAYOUT_miryoku(
<<table-layout-half(half_table=num-r, mode="r", hold_table=hold-flip)>>
  ),
  [SYM] = LAYOUT_miryoku(
<<table-layout-half(half_table=sym-r, mode="r", hold_table=hold-flip)>>
  ),
  [FUN] = LAYOUT_miryoku(
<<table-layout-half(half_table=fun-r, mode="r", hold_table=hold-flip)>>
  ),
#else
  [BASE] = LAYOUT_miryoku(
  #if defined MIRYOKU_ALPHAS_AZERTY
<<table-layout-taphold(alphas_table=azerty)>>
  #elif defined MIRYOKU_ALPHAS_COLEMAK
<<table-layout-taphold(alphas_table=colemak)>>
  #elif defined MIRYOKU_ALPHAS_COLEMAKDHK
<<table-layout-taphold(alphas_table=colemakdhk)>>
  #elif defined MIRYOKU_ALPHAS_DVORAK
<<table-layout-taphold(alphas_table=dvorak)>>
  #elif defined MIRYOKU_ALPHAS_HALMAK
<<table-layout-taphold(alphas_table=halmak)>>
  #elif defined MIRYOKU_ALPHAS_WORKMAN
<<table-layout-taphold(alphas_table=workman)>>
  #elif defined MIRYOKU_ALPHAS_QWERTY
<<table-layout-taphold(alphas_table=qwerty)>>
  #elif defined MIRYOKU_ALPHAS_QWERTZ
<<table-layout-taphold(alphas_table=qwertz)>>
  #else
<<table-layout-taphold(alphas_table=colemakdh)>>
  #endif
  ),
  #if defined MIRYOKU_NAV_VI
  [NAV] = LAYOUT_miryoku(
<<table-layout-half(half_table=nav-r-vi, mode="r")>>
  ),
  [MOUSE] = LAYOUT_miryoku(
<<table-layout-half(half_table=mouse-r-vi, mode="r")>>
  ),
  [MEDIA] = LAYOUT_miryoku(
<<table-layout-half(half_table=media-r-vi, mode="r")>>
  ),
  #else
  [NAV] = LAYOUT_miryoku(
<<table-layout-half(half_table=nav-r, mode="r")>>
  ),
  [MOUSE] = LAYOUT_miryoku(
<<table-layout-half(half_table=mouse-r, mode="r")>>
  ),
  [MEDIA] = LAYOUT_miryoku(
<<table-layout-half(half_table=media-r, mode="r")>>
  ),
  #endif
  [NUM] = LAYOUT_miryoku(
<<table-layout-half(half_table=num-l, mode="l")>>
  ),
  [SYM] = LAYOUT_miryoku(
<<table-layout-half(half_table=sym-l, mode="l")>>
  ),
  [FUN] = LAYOUT_miryoku(
<<table-layout-half(half_table=fun-l, mode="l")>>
  ),
#endif
  [BUTTON] = LAYOUT_miryoku(
<<table-layout-full(table=button)>>
  )
};
#+END_SRC


*** Miryoku ZMK


**** [[zmk/layers.h]

#+BEGIN_SRC C :main no :noweb yes :padline no :tangle zmk/layers.h
// Copyright 2021 Manna Harbour
// https://github.com/manna-harbour/miryoku
// generated -*- buffer-read-only: t -*-

<<table-layer-defines()>>

#+END_SRC


**** [[zmk/clipboard.h]

#+BEGIN_SRC C :main no :noweb yes :padline no :tangle zmk/clipboard.h
// Copyright 2021 Manna Harbour
// https://github.com/manna-harbour/miryoku
// generated -*- buffer-read-only: t -*-

#if defined MIRYOKU_CLIPBOARD_FUN
<<table-keycode-mappings-zmk(table=clipboard-fun)>>
#elif defined MIRYOKU_CLIPBOARD_MAC
<<table-keycode-mappings-zmk(table=clipboard-mac)>>
#elif defined MIRYOKU_CLIPBOARD_WIN
<<table-keycode-mappings-zmk(table=clipboard-win)>>
#else
<<table-keycode-mappings-zmk(table=clipboard)>>
#endif

#+END_SRC


**** [[zmk/keymap.dtsi]]

#+BEGIN_SRC C :main no :noweb yes :padline no :tangle zmk/keymap.dtsi
// Copyright 2021 Manna Harbour
// https://github.com/manna-harbour/miryoku
// generated -*- buffer-read-only: t -*-


/ {
  keymap {
    compatible = "zmk,keymap";
    BASE_layer {
      label = "Base";
      bindings = <
#if defined MIRYOKU_ALPHAS_COLEMAK
        MIRYOKU_MAPPING(
<<table-map-taphold(tap_table=colemak)>>
        )
#elif defined MIRYOKU_ALPHAS_COLEMAKDHK
        MIRYOKU_MAPPING(
<<table-map-taphold(tap_table=colemakdhk)>>
        )
#elif defined MIRYOKU_ALPHAS_DVORAK
        MIRYOKU_MAPPING(
<<table-map-taphold(tap_table=dvorak)>>
        )
#elif defined MIRYOKU_ALPHAS_HALMAK
        MIRYOKU_MAPPING(
<<table-map-taphold(tap_table=halmak)>>
        )
#elif defined MIRYOKU_ALPHAS_WORKMAN
        MIRYOKU_MAPPING(
<<table-map-taphold(tap_table=workman)>>
        )
#elif defined MIRYOKU_ALPHAS_QWERTY
        MIRYOKU_MAPPING(
<<table-map-taphold(tap_table=qwerty)>>
        )
#else
        MIRYOKU_MAPPING(
<<table-map-taphold(tap_table=colemakdh)>>
        )
#endif
      >;
    };
    TAP_layer {
      label = "Tap";
      bindings = <
#if defined MIRYOKU_ALPHAS_COLEMAK
        MIRYOKU_MAPPING_TAP(
  <<table-map-full(table=colemak)>>
          )
#elif defined MIRYOKU_ALPHAS_COLEMAKDHK
        MIRYOKU_MAPPING_TAP(
  <<table-map-full(table=colemakdhk)>>
          )
#elif defined MIRYOKU_ALPHAS_DVORAK
        MIRYOKU_MAPPING_TAP(
  <<table-map-full(table=dvorak)>>
          )
#elif defined MIRYOKU_ALPHAS_HALMAK
        MIRYOKU_MAPPING_TAP(
  <<table-map-full(table=halmak)>>
          )
#elif defined MIRYOKU_ALPHAS_WORKMAN
        MIRYOKU_MAPPING_TAP(
  <<table-map-full(table=workman)>>
          )
#elif defined MIRYOKU_ALPHAS_QWERTY
        MIRYOKU_MAPPING_TAP(
  <<table-map-full(table=qwerty)>>
          )
#else
        MIRYOKU_MAPPING_TAP(
  <<table-map-full(table=colemakdh)>>
          )
#endif
      >;
    };
    BUTTON_layer {
      label = "Button";
      bindings = <
        MIRYOKU_MAPPING(
<<table-map-full(table=button)>>
        )
      >;
    };
    NAV_layer {
      label = "Nav";
      bindings = <
#if defined MIRYOKU_NAV_VI
        MIRYOKU_MAPPING(
<<table-map-half(mode="r", half_table=nav-r-vi)>>
        )
#else
        MIRYOKU_MAPPING(
<<table-map-half(mode="r", half_table=nav-r)>>
        )
#endif
      >;
    };
    MOUSE_layer {
      label = "Mouse";
      bindings = <
#if defined MIRYOKU_NAV_VI
        MIRYOKU_MAPPING(
<<table-map-half(mode="r", half_table=mouse-r-vi)>>
        )
#else
        MIRYOKU_MAPPING(
<<table-map-half(mode="r", half_table=mouse-r)>>
        )
#endif
      >;
    };
    MEDIA_layer {
      label = "Media";
      bindings = <
#if defined MIRYOKU_NAV_VI
        MIRYOKU_MAPPING(
<<table-map-half(mode="r", half_table=media-r-vi)>>
        )
#else
        MIRYOKU_MAPPING(
<<table-map-half(mode="r", half_table=media-r)>>
        )
#endif
      >;
    };
    NUM_layer {
      label = "Num";
      bindings = <
        MIRYOKU_MAPPING(
<<table-map-half(mode="l", half_table=num-l)>>
        )
      >;
    };
    SYM_layer {
      label = "Sym";
      bindings = <
        MIRYOKU_MAPPING(
<<table-map-half(mode="l", half_table=sym-l)>>
        )
      >;
    };
    FUN_layer {
      label = "Fun";
      bindings = <
        MIRYOKU_MAPPING(
<<table-map-half(mode="l", half_table=fun-l)>>
        )
      >;
    };
  };
};

#if defined (MIRYOKU_COMBO_TPS_ENABLE) && defined (MIRYOKU_COMBO_TPSL) && defined (MIRYOKU_COMBO_TPSR)
/ {
  combos {
    compatible = "zmk,combos";
    combo_tpsl_BASE {
      timeout-ms = <200>;
      key-positions = <MIRYOKU_COMBO_TPSL>;
      bindings = <&lt MEDIA ESC>;
      layers = <BASE>;
    };
    combo_tpsr_BASE {
      timeout-ms = <200>;
      key-positions = <MIRYOKU_COMBO_TPSR>;
      bindings = <&lt FUN DEL>;
      layers = <BASE>;
    };
    combo_tpsr_BUTTON {
      timeout-ms = <200>;
      key-positions = <MIRYOKU_COMBO_TPSR>;
      bindings = <U_NU>;
      layers = <BUTTON>;
    };
    combo_tpsr_NAV {
      timeout-ms = <200>;
      key-positions = <MIRYOKU_COMBO_TPSR>;
      bindings = <&kp DEL>;
      layers = <NAV>;
    };
    combo_tpsr_MOUSE {
      timeout-ms = <200>;
      key-positions = <MIRYOKU_COMBO_TPSR>;
      bindings = <U_NU>;
      layers = <MOUSE>;
    };
    combo_tpsr_MEDIA {
      timeout-ms = <200>;
      key-positions = <MIRYOKU_COMBO_TPSR>;
      bindings = <&kp K_MUTE>;
      layers = <MEDIA>;
    };
    combo_tpsl_NUM {
      timeout-ms = <200>;
      key-positions = <MIRYOKU_COMBO_TPSL>;
      bindings = <&kp DOT>;
      layers = <NUM>;
    };
    combo_tpsl_SYM {
      timeout-ms = <200>;
      key-positions = <MIRYOKU_COMBO_TPSL>;
      bindings = <&kp LPAR>;
      layers = <SYM>;
    };
    combo_tpsl_FUN {
      timeout-ms = <200>;
      key-positions = <MIRYOKU_COMBO_TPSL>;
      bindings = <&kp K_APP>;
      layers = <FUN>;
    };
  };
};
#endif
#+END_SRC


** 

[[https://github.com/manna-harbour][https://raw.githubusercontent.com/manna-harbour/miryoku/master/data/logos/manna-harbour-boa-32.png]]
